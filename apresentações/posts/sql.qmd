---
title: "5. Do SQL para o R com dbplyr"
subtitle: "Traduza suas queries SQL para o universo tidyverse"
categories: [SQL, R, Web, dbplyr]
image: imagens/sql.png
description: " Traduza suas queries SQL para o universo tidyverse.
√â open use e compartilhe."
format:
  revealjs:
    theme: simple
    logo: "imagens/logo.png"
    transition: slide
    slide-number: true
    chalkboard: true
    preview-links: auto
    css: estilo_jeni.css
    footer: "Jennifer Lopes ‚Ä¢ Caf√© com R"
editor:
  markdown:
    wrap: 72
---

## **‚òï Assine o Caf√© com R**

**Fique por dentro das aulas, conte√∫dos, newsletter!**

> Que cada **gole** desperte uma nova ideia.
>
> Que cada **script** abra uma nova conversa.
>
> Que o **Caf√© com R**, se torne um ponto de encontro nosso!

![](imagens/qrcode.jpg){fig-align="center" width="236"}

## Bem-vindo ao mundo do dbplyr! {background-color="#E5D3B3"}

Se voc√™ j√° sabe SQL e est√° come√ßando com R, esta apresenta√ß√£o √© para
voc√™!

![](https://raw.githubusercontent.com/allisonhorst/stats-illustrations/main/rstats-artwork/dplyr_wrangling.png){fig-align="center"
width="50%"}

::: notes
Allison Horst
:::

------------------------------------------------------------------------

## O que voc√™ vai aprender hoje {background-color="#E5D3B3"}

-   O que √© dbplyr e por que ele √© incr√≠vel
-   Como conectar R a bancos de dados
-   Traduzir SELECT, WHERE, JOIN e muito mais
-   Trabalhar com dados sem carregar tudo na mem√≥ria
-   Exemplos pr√°ticos que voc√™ pode testar agora

**Spoiler**: Voc√™ vai escrever c√≥digo R que gera SQL automaticamente! üéâ

------------------------------------------------------------------------

## O que √© dbplyr? {background-color="#E5D3B3"}

::: {style="color: #6B4F4F;"}
**`dbplyr`** √© um pacote que traduz c√≥digo dplyr (R) para SQL.

**Por que isso √© fant√°stico:**

-   Escreva em R, execute em SQL
-   Trabalhe com milh√µes de linhas sem travamentos
-   Use a sintaxe tidyverse que voc√™ ama
-   Funciona com v√°rios bancos de dados (PostgreSQL, MySQL, SQLite, etc)
-   O R s√≥ traz para mem√≥ria o que voc√™ realmente precisa
:::

------------------------------------------------------------------------

## Dica inicial

> **‚ÄúPense em R, execute em SQL, aprenda os dois!‚Äù**
>
> A cada query voc√™ escreve, est√° praticando DUAS linguagens ao mesmo
> tempo!

![**Imagem: Allison Horst.**](imagens/tidyverse.png){fig-align="center"
width="313"}

## SQL x dplyr: A grande compara√ß√£o {background-color="#E5D3B3"}

``` sql
-- Em SQL
SELECT nome, idade 
FROM clientes 
WHERE idade > 18;
```

```{r}
#| eval: false
# Em dplyr (R)
clientes |>
  filter(idade > 18) |>
  select(nome, idade)
```

**Mesma l√≥gica, sintaxe diferente!**

------------------------------------------------------------------------

## Instalando o que voc√™ precisa {background-color="#E5D3B3"}

::: {style="color: #6B4F4F;"}
Primeiro, instale os pacotes necess√°rios:

```{r}
#| eval: false
# Instalar pacotes (faz UMA vez)
install.packages("DBI")
install.packages("RSQLite")  
install.packages("dbplyr")
install.packages("dplyr")
```

-   **`DBI`**: Interface com bancos de dados
-   **`RSQLite`**: Para trabalhar com SQLite
-   **`dbplyr`**: O tradutor SQL `‚Üî` R
-   **`dplyr`**: Manipula√ß√£o de dados
:::

------------------------------------------------------------------------

## Carregando os pacotes {background-color="#E5D3B3"}

```{r}
#| echo: true
#| message: false
# Carregar pacotes (faz TODA vez)
library(DBI)
library(dplyr)
library(dbplyr)
```

**Lembre-se**: Instalar √© como baixar o app, carregar √© como abrir o
app!

------------------------------------------------------------------------

## Criando um banco de dados de exemplo {background-color="#E5D3B3"}

Vamos criar um banco SQLite em mem√≥ria para praticar:

```{r}
#| echo: true
# Criar conex√£o com banco em mem√≥ria
con <- dbConnect(RSQLite::SQLite(), ":memory:")

# Criar tabela de clientes
dbWriteTable(con, "clientes", data.frame(
  id = 1:5,
  nome = c("Ana", "Jennifer", "Carla", "Daniel", "Elena"),
  idade = c(25, 33, 22, 35, 28),
  cidade = c("RJ", "SP", "SP", "MG", "RJ")))
```

**Pronto!** Agora temos um banco de dados para trabalhar.

------------------------------------------------------------------------

## Conectando ao banco

Para usar dbplyr, conecte-se √† tabela:

```{r}
#| echo: true
# Criar refer√™ncia √† tabela
clientes_db <- tbl(con, "clientes")

# Ver os dados
clientes_db
```

**Importante**: Os dados ainda est√£o no banco, n√£o na mem√≥ria do R!

------------------------------------------------------------------------

## SELECT: Selecionando colunas {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT nome, idade FROM clientes;
```

**dbplyr (R):**

```{r}
#| echo: true
clientes_db |>
  select(nome, idade)
```

------------------------------------------------------------------------

## WHERE: Filtrando linhas {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM clientes WHERE idade > 25;
```

**dbplyr (R):**

```{r}
#| echo: true
clientes_db |>
  filter(idade > 25)
```

------------------------------------------------------------------------

## Operadores de compara√ß√£o

| SQL          | R (dplyr) | Significado    |
|--------------|-----------|----------------|
| `=`          | `==`      | Igual          |
| `<>` ou `!=` | `!=`      | Diferente      |
| `>`          | `>`       | Maior que      |
| `<`          | `<`       | Menor que      |
| `>=`         | `>=`      | Maior ou igual |
| `<=`         | `<=`      | Menor ou igual |

**Aten√ß√£o**: Em R use `==` para compara√ß√£o, n√£o `=`

------------------------------------------------------------------------

## Combinando filtros com AND {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM clientes 
WHERE idade > 25 AND cidade = 'SP';
```

**dbplyr (R):**Use `&` para AND (E)

```{r}
#| echo: true
clientes_db |>
  filter(idade > 25 & cidade == "SP")
```

------------------------------------------------------------------------

## Combinando filtros com OR {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM clientes 
WHERE cidade = 'SP' OR cidade = 'RJ';
```

**dbplyr (R):** Use `|` para OR (OU)

```{r}
#| echo: true
clientes_db |>
  filter(cidade == "SP" | cidade == "RJ")
```

------------------------------------------------------------------------

## IN: Valores em uma lista {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM clientes 
WHERE cidade IN ('SP', 'RJ');
```

**dbplyr (R):**`%in%` verifica se o valor est√° no vetor

```{r}
#| echo: true
clientes_db |>
  filter(cidade %in% c("SP", "RJ"))
```

------------------------------------------------------------------------

## ORDER BY: Ordenando resultados {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM clientes ORDER BY idade DESC;
```

**dbplyr (R):** Use `arrange()` para ordenar, `desc()` para decrescente

```{r}
#| echo: true
clientes_db |>
  arrange(desc(idade))
```

------------------------------------------------------------------------

## LIMIT: Limitando resultados {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM clientes LIMIT 3;
```

**dbplyr (R):**

```{r}
#| echo: true
clientes_db |>
  head(3)
```

------------------------------------------------------------------------

## COUNT: Contando registros {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT COUNT(*) FROM clientes;
```

**dbplyr (R):**

```{r}
#| echo: true
clientes_db |>
  summarise(total = n())
```

`n()` conta o n√∫mero de linhas

------------------------------------------------------------------------

## GROUP BY: Agrupando dados {background-color="#E5D3B3"}

Vamos criar uma tabela de vendas para exemplos mais interessantes:

```{r}
#| echo: true
dbWriteTable(con, "vendas", data.frame(
  id = 1:8,
  cliente_id = c(1, 2, 1, 3, 2, 1, 4, 5),
  produto = c("A", "B", "A", "C", "B", "C", "A", "B"),
  valor = c(100, 150, 200, 80, 120, 90, 110, 160),
  quantidade = c(2, 1, 3, 1, 2, 1, 2, 1)), overwrite = TRUE)

vendas_db <- tbl(con, "vendas")
```

------------------------------------------------------------------------

## GROUP BY com COUNT {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT produto, COUNT(*) as total_vendas
FROM vendas
GROUP BY produto;
```

**dbplyr (R):**

```{r}
#| echo: true
vendas_db |>
  group_by(produto) |>
  summarise(total_vendas = n())
```

------------------------------------------------------------------------

## GROUP BY com SUM {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT produto, SUM(valor) as receita_total
FROM vendas
GROUP BY produto;
```

**dbplyr (R):**

```{r}
#| echo: true
vendas_db |>
  group_by(produto) |>
  summarise(receita_total = sum(valor, na.rm = TRUE))
```

------------------------------------------------------------------------

## M√∫ltiplas agrega√ß√µes {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT produto, 
       COUNT(*) as vendas,
       SUM(valor) as receita,
       AVG(valor) as ticket_medio
FROM vendas
GROUP BY produto;
```

## M√∫ltiplas agrega√ß√µes {background-color="#E5D3B3"}

**dbplyr (R):**

```{r}
#| echo: true
vendas_db |>
  group_by(produto) |>
  summarise(
    vendas = n(),
    receita = sum(valor, na.rm = TRUE),
    ticket_medio = mean(valor, na.rm = TRUE))
```

------------------------------------------------------------------------

## Fun√ß√µes de agrega√ß√£o

| SQL        | R (dplyr) | Fun√ß√£o         |
|------------|-----------|----------------|
| `COUNT(*)` | `n()`     | Contar linhas  |
| `SUM()`    | `sum()`   | Somar valores  |
| `AVG()`    | `mean()`  | Calcular m√©dia |
| `MIN()`    | `min()`   | Valor m√≠nimo   |
| `MAX()`    | `max()`   | Valor m√°ximo   |

**Dica**: Sempre use `na.rm = TRUE` em R para ignorar valores NA

------------------------------------------------------------------------

## HAVING: Filtrando grupos {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT produto, SUM(valor) as receita
FROM vendas
GROUP BY produto
HAVING SUM(valor) > 200;
```

**dbplyr (R):**

```{r}
#| echo: true
vendas_db |>
  group_by(produto) |>
  summarise(receita = sum(valor, na.rm = TRUE)) |>
  filter(receita > 200)
```

------------------------------------------------------------------------

## INNER JOIN: Juntando tabelas {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT c.nome, v.produto, v.valor
FROM clientes c
INNER JOIN vendas v ON c.id = v.cliente_id;
```

**dbplyr (R):**

```{r}
#| echo: true
clientes_db |>
  inner_join(vendas_db, by = c("id" = "cliente_id")) |>
  select(nome, produto, valor)
```

------------------------------------------------------------------------

## LEFT JOIN {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT c.nome, v.produto
FROM clientes c
LEFT JOIN vendas v ON c.id = v.cliente_id;
```

**dbplyr (R):**

```{r}
#| echo: true
clientes_db |>
  left_join(vendas_db, by = c("id" = "cliente_id")) |>
  select(nome, produto)
```

------------------------------------------------------------------------

## Tipos de JOIN

| SQL          | R (dplyr)      | O que faz                       |
|--------------|----------------|---------------------------------|
| `INNER JOIN` | `inner_join()` | Apenas registros que combinam   |
| `LEFT JOIN`  | `left_join()`  | Todos da esquerda + combina√ß√µes |
| `RIGHT JOIN` | `right_join()` | Todos da direita + combina√ß√µes  |
| `FULL JOIN`  | `full_join()`  | Todos os registros              |

**Mem√≥ria**: O nome indica qual tabela mant√©m todos os registros

------------------------------------------------------------------------

## CASE WHEN: Criando categorias {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT nome, idade,
  CASE 
    WHEN idade < 25 THEN 'Jovem'
    WHEN idade < 30 THEN 'Adulto'
    ELSE 'Experiente'
  END as faixa_etaria
FROM clientes;
```

------------------------------------------------------------------------

## CASE WHEN em R {background-color="#E5D3B3"}

**dbplyr (R):** Use `TRUE` como "ELSE"

```{r}
#| echo: true
clientes_db |>
  mutate(
    faixa_etaria = case_when(
      idade < 25 ~ "Jovem",
      idade < 30 ~ "Adulto",
      TRUE ~ "Experiente")) |>
  select(nome, idade, faixa_etaria)
```

------------------------------------------------------------------------

## Criando novas colunas {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT *, valor * quantidade as total
FROM vendas;
```

**dbplyr (R):**

```{r}
#| echo: true
vendas_db |>
  mutate(total = valor * quantidade)
```

`mutate()` cria ou modifica colunas

------------------------------------------------------------------------

## DISTINCT: Valores √∫nicos {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT DISTINCT cidade FROM clientes;
```

**dbplyr (R):**

```{r}
#| echo: true
clientes_db |>
  distinct(cidade)
```

------------------------------------------------------------------------

## Subconsultas (Subqueries) {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM vendas
WHERE valor > (SELECT AVG(valor) FROM vendas);
```

**dbplyr (R):**

```{r}
#| echo: true
# Calcular a m√©dia
valor_medio <- vendas_db |>
  summarise(media = mean(valor, na.rm = TRUE)) |>
  pull(media)

# Filtrar
vendas_db |>
  filter(valor > valor_medio)
```

------------------------------------------------------------------------

## LIKE: Buscas com padr√µes {background-color="#E5D3B3"}

**SQL:**

``` sql
SELECT * FROM clientes 
WHERE nome LIKE 'A%';
```

## **dbplyr (R):**

```{r}
#| echo: true 
# clientes_db |> 
# filter(str_detect(nome, "^A"))
```

Use `str_detect()` do pacote `stringr` (parte do tidyverse)

------------------------------------------------------------------------

## Vendo o SQL gerado

Quer ver qual SQL o dbplyr est√° gerando? Use `show_query()`:

```{r}
#| echo: true
clientes_db |>
  filter(idade > 25) |>
  select(nome, cidade) |>
  show_query()
```

**Perfeito para aprender!** Compare seu c√≥digo R com o SQL gerado.

------------------------------------------------------------------------

## Executando e coletando dados {background-color="#E5D3B3"}

O dbplyr √© "lazy" (pregui√ßoso) - s√≥ executa quando necess√°rio.

```{r}
#| echo: true
# Isso N√ÉO executa ainda, s√≥ prepara a query
query <- clientes_db |>
  filter(idade > 25)

# Isso executa e traz para o R
resultado <- query |> collect()

# Agora √© um data.frame normal no R
class(resultado)
```

------------------------------------------------------------------------

## Por que usar collect()? {background-color="#E5D3B3"}

::: {style="color: #6B4F4F;"}
**Sem `collect():`**

-   Dados ficam no banco

-   Opera√ß√µes r√°pidas (SQL √© otimizado)

-   Economiza mem√≥ria
:::

## Por que usar collect()? {background-color="#E5D3B3"}

::: {style="color: #6B4F4F;"}
**Com `collect()`:**

-   Dados v√™m para o R

-   Use quando precisar processar no R

-   Use depois de filtrar para trazer menos dados

**Dica**: Filtre e agregue NO BANCO, s√≥ depois traga para o R!
:::

------------------------------------------------------------------------

## Exemplo: An√°lise {background-color="#E5D3B3"}

```{r}
#| echo: true
# 1. Fazer query complexa no banco
relatorio <- clientes_db |>
  left_join(vendas_db, by = c("id" = "cliente_id")) |>
  filter(!is.na(valor)) |>
  group_by(nome, cidade) |>
  summarise(
    total_compras = n(),
    valor_total = sum(valor, na.rm = TRUE),
    ticket_medio = mean(valor, na.rm = TRUE)) |>
  arrange(desc(valor_total))
```

## Exemplo: An√°lise - Resultado SQL {background-color="#E5D3B3"}

```{r}
# 2. Ver o SQL que ser√° executado
show_query(relatorio)
```

------------------------------------------------------------------------

## Coletando o resultado {background-color="#E5D3B3"}

```{r}
#| echo: true
# 3. Executar e trazer para o R
resultado_final <- relatorio |> collect()

# 4. Agora voc√™ pode usar ggplot2, etc
print(resultado_final)
```

**Perfeito!** Processamos tudo no banco e s√≥ trouxemos o resultado
final.

------------------------------------------------------------------------

## Conectando a bancos reais

**PostgreSQL:**

```{r}
#| eval: false
#| echo: true
library(RPostgres)
con <- dbConnect(
  RPostgres::Postgres(),
  dbname = "seu_banco",
  host = "localhost",
  port = 5432,
  user = "seu_usuario",
  password = "sua_senha")
```

------------------------------------------------------------------------

## Conectando a bancos reais (cont.)

**MySQL:**

```{r}
#| eval: false
#| echo: true
library(RMariaDB)
con <- dbConnect(
  RMariaDB::MariaDB(),
  dbname = "seu_banco",
  host = "localhost",
  user = "seu_usuario",
  password = "sua_senha")
```

------------------------------------------------------------------------

## Boas pr√°ticas com bancos {background-color="#E5D3B3"}

**1. Sempre feche a conex√£o:**

```{r}
#| eval: false
#| echo: true
dbDisconnect(con)
```

**2. Filtre ANTES de collect():**

```{r}
#| eval: false
#| echo: true
# ‚úÖ Bom - filtra no banco
dados |> filter(ano == 2024) |> collect()

# ‚ùå Ruim - traz tudo para depois filtrar
dados |> collect() |> filter(ano == 2024)
```

------------------------------------------------------------------------

## Boas pr√°ticas (cont.) {background-color="#E5D3B3"}

**3. Use √≠ndices no banco de dados:**

```{r}
#| eval: false
#| echo: true
# Criar √≠ndice (SQL)
dbExecute(con, "CREATE INDEX idx_cliente ON vendas(cliente_id)")
```

**4. Teste com LIMIT primeiro:**

```{r}
#| eval: false
#| echo: true
# Ver amostra antes de processar tudo
minha_tabela |> head(100) |> collect()
```

------------------------------------------------------------------------

## Tabela de tradu√ß√£o SQL \> dplyr

| SQL                     | dplyr                         | Fun√ß√£o           |
|-------------------------|-------------------------------|------------------|
| `SELECT`                | `select()`                    | Escolher colunas |
| `WHERE`                 | `filter()`                    | Filtrar linhas   |
| `ORDER BY`              | `arrange()`                   | Ordenar          |
| `GROUP BY`              | `group_by()`                  | Agrupar          |
| Agrega√ß√µes + `GROUP BY` | `summarise()`                 | Resumir          |
| `HAVING`                | `filter()` ap√≥s `summarise()` | Filtrar grupos   |

------------------------------------------------------------------------

## Tabela de tradu√ß√£o SQL \> dplyr (cont.)

| SQL          | dplyr          | Fun√ß√£o                |
|--------------|----------------|-----------------------|
| `LIMIT`      | `head()`       | Limitar resultados    |
| `DISTINCT`   | `distinct()`   | Valores √∫nicos        |
| `INNER JOIN` | `inner_join()` | Interse√ß√£o            |
| `LEFT JOIN`  | `left_join()`  | Esquerda + combina√ß√£o |
| `RIGHT JOIN` | `right_join()` | Direita + combina√ß√£o  |
| `FULL JOIN`  | `full_join()`  | Uni√£o completa        |
| `CASE WHEN`  | `case_when()`  | Condicionais          |
| Criar coluna | `mutate()`     | Nova vari√°vel         |

------------------------------------------------------------------------

## Exerc√≠cio 1

Desafio: Traduza este SQL para dplyr:

``` sql
SELECT cidade, COUNT(*) as total
FROM clientes
WHERE idade >= 25
GROUP BY cidade
HAVING COUNT(*) > 1
ORDER BY total DESC;
```

Tente fazer sozinho antes de ver a resposta!

------------------------------------------------------------------------

## Solu√ß√£o do exerc√≠cio 1 {background-color="#E5D3B3"}

```{r}
#| echo: true
#| eval: false
clientes_db |>
  filter(idade >= 25) |>
  group_by(cidade) |>
  summarise(total = n()) |>
  filter(total > 1) |>
  arrange(desc(total))
```

**Leia em voz alta**: "Pegue clientes, filtre idade \>= 25, agrupe por
cidade, conte quantos em cada, filtre grupos com mais de 1, ordene por
total decrescente"

------------------------------------------------------------------------

## Exerc√≠cio 2

**Desafio: Crie uma query que:**

1.  Una clientes e vendas
2.  Calcule o valor total por cliente
3.  Mostre apenas clientes com total \> 200
4.  Ordene do maior para o menor

**Tente fazer sozinho!**

------------------------------------------------------------------------

## Solu√ß√£o do exerc√≠cio 2 {background-color="#E5D3B3"}

```{r}
#| echo: true
clientes_db |>
  inner_join(vendas_db, by = c("id" = "cliente_id")) |>
  group_by(nome) |>
  summarise(valor_total = sum(valor, na.rm = TRUE)) |>
  filter(valor_total > 200) |>
  arrange(desc(valor_total))
```

------------------------------------------------------------------------

## Dicas de performance

**1. Projete (select) cedo:**

```{r}
#| eval: false
#| echo: true
# ‚úÖ Melhor - seleciona s√≥ o necess√°rio
tabela |> select(col1, col2) |> filter(...)

# ‚ùå Pior - carrega todas as colunas
tabela |> filter(...) |> select(col1, col2)
```

**2. Filtre no banco, n√£o no R**

**3. Use √≠ndices nas colunas de JOIN e WHERE**

------------------------------------------------------------------------

## Debugando problemas comuns {background-color="#E5D3B3"}

**Erro: "no applicable method"** -Voc√™ tentou usar uma fun√ß√£o que n√£o
funciona com banco

-   Solu√ß√£o: Use `collect()` antes OU use fun√ß√£o equivalente do SQL

## Debugando problemas comuns {background-color="#E5D3B3"}

**Dados n√£o aparecem:** Lembre-se: dbplyr √© lazy!

-   Solu√ß√£o: Use `collect()` ou apenas visualize com `print()`

## Debugando problemas comuns {background-color="#E5D3B3"}

**Query muito lenta:** Est√° trazendo dados demais?

-   Solu√ß√£o: Filtre e agregue ANTES de `collect()`

------------------------------------------------------------------------

## Quando N√ÉO usar dbplyr

**N√£o use dbplyr quando:**

-   Precisar de opera√ß√µes muito espec√≠ficas do R (como modelos
    complexos)
-   Os dados s√£o pequenos (\< 100MB) - s√≥ use `read_csv()`
-   Precisar de loops ou opera√ß√µes iterativas
-   A query SQL j√° est√° pronta e otimizada

## Use dbplyr quando

-   Dados n√£o cabem na mem√≥ria
-   Quer sintaxe R mas poder do banco
-   Est√° explorando dados grandes
-   Precisa combinar v√°rias fontes

## Recursos para continuar {background-color="#E5D3B3"}

**Documenta√ß√£o:**

-   [dbplyr.tidyverse.org](https://dbplyr.tidyverse.org/)
-   [Database using R](https://solutions.posit.co/connections/db/)

**Livros gratuitos:**

-   [R for Data Science - Cap. Databases](https://r4ds.hadley.nz/)

**Pr√°tica:**

-   Use seus pr√≥prios bancos!
-   Comece com SQLite para aprender
-   Depois migre para PostgreSQL/MySQL

------------------------------------------------------------------------

## Projeto pr√°tico sugerido

**Mini projeto para praticar:**

1.  Crie um banco SQLite com 2-3 tabelas relacionadas
2.  Escreva 5 queries SQL que voc√™ j√° conhece
3.  Traduza todas para dbplyr
4.  Compare os resultados
5.  Use `show_query()` para ver o SQL gerado
6.  Identifique padr√µes de tradu√ß√£o

**Isso vai consolidar seu aprendizado!**

------------------------------------------------------------------------

## Cheat sheet r√°pido {background-color="#E5D3B3"}

```{r}
#| eval: false
#| echo: true
# Conectar
con <- dbConnect(RSQLite::SQLite(), "banco.db")
tabela <- tbl(con, "nome_tabela")

# Opera√ß√µes b√°sicas
tabela |> filter(col > 10)        # WHERE
tabela |> select(col1, col2)      # SELECT
tabela |> arrange(col)            # ORDER BY
tabela |> distinct(col)           # DISTINCT

# Agrega√ß√µes
tabela |> group_by(col) |>
  summarise(total = n())          # COUNT

# Joins
left_join(tab1, tab2, by = "id")  # LEFT JOIN

# Executar
tabela |> collect()               # Trazer para R
tabela |> show_query()            # Ver SQL
```

------------------------------------------------------------------------

## Recapitulando {background-color="#E5D3B3"}

**Voc√™ aprendeu:**

-   O que √© **`dbplyr`** e como funciona
-   Conectar R a bancos de dados
-   Traduzir SELECT, WHERE, JOIN, GROUP BY
-   Usar `collect()` e `show_query()`
-   Boas pr√°ticas de performance
-   Quando usar (e n√£o usar) dbplyr

**O melhor**: Voc√™ pode escrever R e deixar o banco fazer o trabalho
pesado!

------------------------------------------------------------------------

## Dica final

**Fluxo ideal:**

1.  Escreva a query em dplyr
2.  Use `show_query()` para ver o SQL
3.  Aprenda com a tradu√ß√£o
4.  Otimize se necess√°rio
5.  Use `collect()` s√≥ no final

**"Pense em R, execute em SQL, aprenda os dois!"**

A cada query voc√™ escreve, est√° praticando DUAS linguagens ao mesmo
tempo!

------------------------------------------------------------------------

## Mensagem final {background-color="#E5D3B3"}

**SQL + R = üí™**

Voc√™ n√£o precisa escolher entre SQL e R.

Com dbplyr, voc√™ tem o melhor dos dois mundos:

-   A eleg√¢ncia do tidyverse
-   O poder e performance do SQL
-   A flexibilidade de escolher quando usar cada um

Continue praticando e explorando!

------------------------------------------------------------------------

## Muito obrigada!

Esta apresenta√ß√£o √© parte do projeto **Caf√© com R**

**√â OPEN, USE, COMPARTILHE!**

Perguntas? D√∫vidas? Sugest√µes?

**Pr√≥ximo passo**: Abra seu RStudio e comece a praticar!

![](https://raw.githubusercontent.com/allisonhorst/stats-illustrations/main/rstats-artwork/welcome_to_rstats_twitter.png){fig-align="center"
width="40%"}

------------------------------------------------------------------------

## Limpando o ambiente {background-color="#E5D3B3"}

N√£o esque√ßa de fechar a conex√£o ao terminar:

```{r}
#| echo: true
# Fechar conex√£o
dbDisconnect(con)
```

**Boa pr√°tica**: Sempre feche conex√µes para liberar recursos!

## **‚òï Assine o Caf√© com R**

**Fique por dentro das aulas, conte√∫dos, newsletter!**

> Que cada **gole** desperte uma nova ideia.
>
> Que cada **script** abra uma nova conversa.
>
> Que o **Caf√© com R**, se torne um ponto de encontro nosso!

![](imagens/qrcode.jpg){fig-align="center" width="236"}
